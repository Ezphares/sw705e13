\section{Interview}

To found the basis for the requirements it was necessary to conduct an interview with someone knowledgeable in the field of teaching programming to students. For that reason, it seemed obvious to set up an interview with the associate professor Kurt N{\o}rmark at the institute. There are many different ways this interview could have been set-up, but the group decided to take a semi-structured approach simply based on good experiences from past 
interviews. 


The semi-structured approach allows us to conduct the interview in a less strict way, which in our experience works better when the goal of the interview is to achieve knowledge and learn-as-we-talk, as opposed to holding the interviewee to certain facts as seen by journalists in media. The interview was conducted by two group members, who had created a list of \textbf{must-answer} questions to help guide and create focus points for the conversation and drive the interview toward a goal. The interview could then be considered successful, once all of these questions had been answered - the details and information given between these questions is then bonus knowledge, that we would not have otherwise achieved, if the interview was a strict, and fully structured interview.

One of the participants at the interview was responsible for writing down the interviewee's answers, and participated only somewhat in keeping the conversation going, whereas the other interviewer was responsible for keeping the conversation going entirely and asking new questions, when necessary. The main questions that were posed during the interview are:

\begin{itemize}
	\item \todo{Comment from Martin: try to reformulate ... it could be smt like the following question:

Are there any advantages when teaching first year university students to program with Imperative Programming paradigm instead of other paradigms (Object Oriented, Functional) as the initial part of the programming course?} Which advantages are there teaching students how to program in the Imperative Paradigm first, and not - for example, Object 
	Oriented or Functionally?
	\item Which disadvantages are there?
	\item What is the biggest difficulty for new students when they are introduced to imperative programming?
	\item Which programming constructs / types are the most difficult for students to understand (in the imperative paradigm)?
	\item What would you like the students to be better at, when they begin the Imperative Programming course?
\end{itemize}


\subsection{Results of the Interview}

The following will go through the main points of interest for each of the questions that were asked. Notice that the questions below has been slightly reformulated to better fit the knowledge that was given throughout the interview. They correspond to the questions in the previous section, but information has been added, as was given during the interview.

\subsubsection{Why is the Imperative Paradigm taught first, and not a different paradigm?}

Starting with the \textbf{Object-Oriented Paradigm} seemed counter intuitive, because it would teach the students how to classify their code, but not write their code. One of the main points that were brought across for this question was that it was important in the beginning that the student understood how to write code, before they started to worry about classification of this code and storing it in classes. In other words, it is important that the student understands \textbf{what} to structure \textbf{before} he/she structures, and this can not necessarily be taught to new students by starting off with the \textbf{Object-Oriented Paradigm} or rather - perhaps it could, but it would be more efficient to teach by using a different paradigm first. 


As for not using the \textbf{Functional Paradigm}, Kurt N{\o}rmark actually believes that starting with the functional paradigm is the most sensible way of teaching programming to new students, because it is very mathematically inspired, the level of abstraction is much higher, and so it would be easier for a student to simply see the code they write in a more mathematical way. In other words, the \textbf{Functional Paradigm} would be ideal for students, who has completed \textbf{Math A}, which would teach students how to call functions with functions (think integral and differential equations) - Math A is a prerequisite for the \textbf{Software Engineering} and \textbf{Computer Science} education at Aalborg University.\todo{Source on prerequisite}


For students who has not yet completed \textbf{Math A} or may have, but are not comfortable with mathematics, starting in the Imperative Paradigm would arguably be a much better decision. The basic philosophy behind the imperative paradigm is 'first-do-this and next-to-that'. This philosophy is known to many as a listed structure like in manuals or recipes, which is also an argument for starting with the imperative paradigm.


\subsubsection{What is the biggest difficulty for new students that are introduced to imperative programming?}

There are many parts to the problem for a new student who has to learn how to program from scratch. However, a recurring theme is the level of abstraction. It can be quite a mouthful for some new students to understand a low level language, which often is used for the Imperative Paradigm, - think C. Things that execute sequentially are generally not so difficult to understand, but it can be very difficult to understand the low level mechanics of the computer, and how the language interacts with the machine. This leads to the conclusion that the lower the level of abstraction, the more difficult it is to understand for new students.

\subsubsection{Which programming constructs / types are the most difficult for students to understand (in the imperative paradigm)?}

It is not so much a problem with the constructs - \textbf{for's} and \textbf{while's} are generally simple to understand for the students, but implicit constructs like recursion can be a bit of a mouthful, and even so for more experienced programmers who has completed several semesters in the education. As for types, understanding that a Boolean type is as valid a type as an int or a char, can be difficult for the students - computing more complex, or large boolean expressions can cloud the execution of a students program extensively, and make them lose track in the flow of their program, which leads to errors and confusion. Using operators such as bit shifting can also be tricky for the students, which is a result of the very low level of abstraction this yields for the students, which backs up the point noticed previously; the lower the level of abstraction, the more difficult it is to understand - the higher the level of abstraction, the easier it is to understand.
\todo{Comment from Martin: I like this interview ... valuable part of your report .. try to summarize either here or in the requirements part what did you find out here and how does it affect your project.}