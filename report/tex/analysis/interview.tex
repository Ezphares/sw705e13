\section{Interview}
\label{sec:interview}
To found the basis for the requirements, it is useful to conduct an interview with someone knowledgeable in the field of teaching programming to 
students.
For that reason, we interviewed associate professor Kurt N{\o}rmark at Department of Computer Science, AAU.
There are many different ways, that this interview could have been structured, but the group decided to take a semi-structured approach based on good experiences from past interviews.
The semi-structured approach allows us to conduct the interview in a less strict way, which, in our experience, works better when the goal of the interview is to achieve knowledge and learn-as-we-talk.
The interview was conducted by two group members, who had created a list of \textbf{must-answer} questions to help guide and create focus points for the interview and drive it towards gaining information about teaching programming to students.
The interview could be considered successful, once all of these questions had been answered.
The details and information given between these questions is then bonus knowledge, that we would not have otherwise achieved, if the interview was a strict, and fully structured interview.\newline

One of the interviewers was responsible for writing down the interviewee's answers, and participated only somewhat in keeping the conversation going, whereas the other interviewer was responsible for asking new questions, when necessary. 
The main questions that were posed during the interview were:

\begin{itemize}
	\item Which advantages are there to teaching students how to program in the Imperative Paradigm first, and not in a different paradigm?
	\item Which disadvantages are there?
	\item What is the biggest difficulty for new students when they are introduced to imperative programming?
	\item Which programming constructs / types are the most difficult for students to understand (in the imperative paradigm)?
	\item What would you like the students to be better at, when they begin the Imperative Programming course?
\end{itemize}

\subsection{Results of the Interview}
The following will go through the main points of interest for each of the questions, that was asked.
Notice that the questions below have been slightly reformulated to better fit the knowledge, that was provided throughout the interview.
The modified questions correspond to the original questions, but information has been added, as was given during the interview.

\subsubsection{Why is the imperative paradigm taught first, and not a different paradigm?}

Starting with the \textbf{Object-Oriented Paradigm} seemed counter intuitive, because it would teach the students how to classify their code, but not write their code.
One of the main points, that were brought across for this question was, that it was important in the beginning of learning to program, that the students understand how to write code, before they start to worry about the classification of the code and storing it in classes.
In other words, it is important 
that the student understands \textbf{what} to structure before they understand \textbf{how} to structure it, and this can not necessarily be taught to new students by starting off with the \textbf{Object-Oriented Paradigm} or rather - perhaps it could, but according to Kurt N{\o}rmark, it would be more efficient to teach by using a different paradigm first.\newline

As for not using the \textbf{Functional Paradigm}, Kurt N{\o}rmark believes that starting with the functional paradigm is the most sensible way of teaching programming to new students. This is because it is very mathematically inspired, the level of abstraction is much higher, and so it would be easier for a student to simply see the code they write in a more mathematical way.
In other words, the \textbf{Functional Paradigm} would be ideal for students, who have been taught integral and differential equations.
 - Math at this level is a prerequisite for the \textbf{Software Engineering} and \textbf{Computer Science} education at Aalborg University.\cite{UG}\newline

For students who have not yet completed Math at this level or may have, but are not comfortable with mathematics, starting in the \textbf{Imperative Paradigm} would be a better decision.
The basic philosophy behind the \textbf{Imperative Paradigm} is 'first-do-this and next-to-that'.
This philosophy is known to many as a listed structure like in manuals or recipes, which is also an argument for starting with the \textbf{Imperative Paradigm}.

\subsubsection{What is the biggest difficulty for new students that are introduced to imperative programming?}

There are many facets of the problem for a new student, who has to learn how to program from scratch.
However, a recurring theme is the level of abstraction.
It can be quite a mouthful for some new students to understand a low level language, which often is used for the imperative paradigm, e.g. \texttt{C}.
Things that execute sequentially are generally not so difficult to understand, but it can be very difficult to understand the low level 
mechanics of the computer, and how the language interacts with the machine.
This leads to the conclusion, that the lower the level of abstraction, the more difficult it is to understand for new students.

\subsubsection{Which programming constructs/types are the most difficult for students to understand (in the imperative paradigm)?}

It is not so much a problem with the constructs - \textbf{for-} and \textbf{while-loops} are generally simple to understand for the students, but implicit constructs like recursion can be a bit of a mouthful, and even so for more experienced programmers who have completed several semesters in the education.
As for types, understanding that Boolean (bool) is as valid a type as an Integer (int) or a Character (char), can be difficult for the student.
Computing more complex, or large boolean expressions can cloud the overview that the student otherwise should have of the execution flow of their program and make them lose track of the flow of their program, which might lead to errors and confusion.
Using operators such as bit shifting can also be tricky for the students, which is a result of the very low level of abstraction, which backs up the point noted previously: the lower the level of abstraction, the more difficult it is to understand.

\subsection{Summary}

The interview yielded useful results for the project, and taught us what aspects of programming are more difficult for a new programmer to understand.
The above findings will be summarized in the following paragraphs.

\subsubsection{Constructs}

One of the key findings of the interview was the discussion on level of abstraction, and how it was relevant for constructs.
As a rule of thumb, Kurt N{\o}rmark explained, that the level of abstraction should reflect the constructs used within the program.
Consider the following example: a 
higher level language such as \texttt{Java} makes use of a \verb|for each| construct, which allows the programmer to iterate through the elements in a list easily.
A \texttt{C} equivalent could be a for-loop construct, which would iterate through an array, with explicitly stated variables that are incremented at each pass through the loop.
The way the \textbf{for} constructs have been implemented in the two languages, makes it easy to see that \texttt{C} has a much lower level of abstraction, than \texttt{Java} does, because you do not explicitly declare conditionals or variables. 
However, the \texttt{C}-styled for-loop construct have also been implemented in \texttt{Java}, so both approaches to iteration can be taken in \texttt{Java}.

\subsubsection{Target Group}

Determining the paradigm of our game will largely depend on its target group.
It turns out that if the user of our game has learned Calculus and has a good understanding of it, it would be better to let the game focus on teaching constructs from the functional paradigm, because the user could relate to this and Kurt N{\o}rmark suggest, that starting with the functional paradigm is more intuitive.
Otherwise, it would be better to start with the step based approach of the imperative paradigm.
This could also be the case if the students are generally not very strong in math even though they have passed their exam in Calculus.

\subsubsection{Sequential Execution}

Boolean types and expressions can prove to be a challenge for a new programmers to understand because they can obscure the flow of execution through a program.
The simpler the execution of the program, the easier it is to grasp for the student.
It may be obvious that the Sequential Execution is the simplest form of execution there is, but if the program includes boolean types or expressions, it is not always obvious which line of code will be executed next.
Therefore to make the program simple to understand and read, sequential execution would work best, with a minimum of boolean expressions, which is the hardest type of expression to understand.

\subsubsection{Level of Abstraction}

The lower the level of abstraction the more the programmer needs to know about the computer.
Therefore, a higher level of abstraction is considered easier for students to learn than a language with a low level of abstraction.