\section{Interview}
\label{sec:interview}

To found the basis for the requirements it was necessary to conduct an interview with someone knowledgeable in the field of teaching programming to 
students. For that reason, it seemed obvious to set up an interview with the associate professor Kurt N{\o}rmark at the institute. There are many 
different ways this interview could have been set-up, but the group decided to take a semi-structured approach simply based on good experiences from 
past interviews. 


The semi-structured approach allows us to conduct the interview in a less strict way, which in our experience works better when the goal of the 
interview is to achieve knowledge and learn-as-we-talk, as opposed to holding the interviewee to certain facts as seen by journalists in media. The 
interview was conducted by two group members, who had created a list of \textbf{must-answer} questions to help guide and create focus points for the 
conversation and drive the interview toward a goal. The interview could then be considered successful, once all of these questions had been answered - 
the details and information given between these questions is then bonus knowledge, that we would not have otherwise achieved, if the interview was a 
strict, and fully structured interview.

One of the participants at the interview was responsible for writing down the interviewee's answers, and participated only somewhat in keeping the 
conversation going, whereas the other interviewer was responsible for keeping the conversation going entirely and asking new questions, when necessary. 
The main questions that were posed during the interview are:

\begin{itemize}
	\item Which advantages are there teaching students how to program in the Imperative Paradigm first, and not in a different paradigm?
	\item Which disadvantages are there?
	\item What is the biggest difficulty for new students when they are introduced to imperative programming?
	\item Which programming constructs / types are the most difficult for students to understand (in the imperative paradigm)?
	\item What would you like the students to be better at, when they begin the Imperative Programming course?
\end{itemize}


\subsection{Results of the Interview}

The following will go through the main points of interest for each of the questions that were asked. Notice that the questions below has been slightly 
reformulated to better fit the knowledge that was given throughout the interview. They correspond to the questions in the previous section, but 
information has been added, as was given during the interview.

\subsubsection{Why is the Imperative Paradigm taught first, and not a different paradigm?}

Starting with the \textbf{Object-Oriented Paradigm} seemed counter intuitive, because it would teach the students how to classify their code, but not 
write their code. One of the main points that were brought across for this question was that it was important in the beginning that the student 
understood how to write code, before they started to worry about classification of this code and storing it in classes. In other words, it is important 
that the student understands \textbf{what} to structure \textbf{before} he/she structures, and this can not necessarily be taught to new students by 
starting off with the \textbf{Object-Oriented Paradigm} or rather - perhaps it could, but it would be more efficient to teach by using a different 
paradigm first. 


As for not using the \textbf{Functional Paradigm}, Kurt N{\o}rmark actually believes that starting with the functional paradigm is the most sensible 
way of teaching programming to new students, because it is very mathematically inspired, the level of abstraction is much higher, and so it would be 
easier for a student to simply see the code they write in a more mathematical way. In other words, the \textbf{Functional Paradigm} would be ideal for 
students, who has completed \textbf{Math A}, which would teach students how to call functions with functions (think integral and differential equations)
 - Math A is a prerequisite for the \textbf{Software Engineering} and \textbf{Computer Science} education at Aalborg University.\todo{Source on 
prerequisite}


For students who has not yet completed \textbf{Math A} or may have, but are not comfortable with mathematics, starting in the Imperative Paradigm would 
arguably be a much better decision. The basic philosophy behind the imperative paradigm is 'first-do-this and next-to-that'. This philosophy is known 
to many as a listed structure like in manuals or recipes, which is also an argument for starting with the imperative paradigm.


\subsubsection{What is the biggest difficulty for new students that are introduced to imperative programming?}

There are many parts to the problem for a new student who has to learn how to program from scratch. However, a recurring theme is the level of 
abstraction. It can be quite a mouthful for some new students to understand a low level language, which often is used for the Imperative Paradigm, - 
think C. Things that execute sequentially are generally not so difficult to understand, but it can be very difficult to understand the low level 
mechanics of the computer, and how the language interacts with the machine. This leads to the conclusion that the lower the level of abstraction, the 
more difficult it is to understand for new students.

\subsubsection{Which programming constructs / types are the most difficult for students to understand (in the imperative paradigm)?}

It is not so much a problem with the constructs - \textbf{for's} and \textbf{while's} are generally simple to understand for the students, but implicit 
constructs like recursion can be a bit of a mouthful, and even so for more experienced programmers who has completed several semesters in the 
education. As for types, understanding that a Boolean type is as valid a type as an int or a char, can be difficult for the students - computing more 
complex, or large boolean expressions can cloud the execution of a students program extensively, and make them lose track in the flow of their program, 
which leads to errors and confusion. Using operators such as bit shifting can also be tricky for the students, which is a result of the very low level 
of abstraction this yields for the students, which backs up the point noticed previously; the lower the level of abstraction, the more difficult it is 
to understand - the higher the level of abstraction, the easier it is to understand.


\subsection{Conclusion}

The interview yielded useful results for the project, and taught us what aspects of programming are more difficult for a new programmer to wrap 
their mind around. The above findings will be summarized in the below paragraphs.

\subsubsection{Constructs}

One of the key findings of the interview was the discussion on \textbf{level of abstraction} and how it was relevant for constructs. As a rule of 
thumb, Kurt N{\o}rmark explained that the level of abstraction should reflect the constructs used within the program. Consider the following example, a 
higher level language such as Java makes use of a \textbf{for-each} construct which allows the programmer to iterate through the elements in a list 
easily - on a single line of code in fact. A C equivalent could be a \textbf{for} construct, which would iterate through an array, with explicitly 
stated variables that are incremented at each pass through the loop. By the way the \textbf{for} constructs has been implemented in the two languages 
it is easy to see that C has a much lower level of abstraction, than Java does, because you do not explicitly declare conditionals or variables. 
However, the C-like \textbf{for} construct has also been implemented in Java (it uses both kinds). 

\subsubsection{Target Group}

Determining the paradigm of our program will largely depend on the target group for the software. It turns out that if students are mathematically 
educated - or rather, students have completed up to \textbf{Math A}, it would be better to let the software follow the Functional Paradigm, because 
they could better relate to our software this way - they have seen it before, basically. Otherwise it would be far better to start with the Imperative 
Paradigm. This could also be the case if the students are generally not very strong mathematically though they have completed \textbf{Math A}.

\subsubsection{Sequential Execution}

The reason Boolean types in languages can prove to be a bit of a mouthful for a new programmer to understand is that they can obfuscate the trace of 
execution through the program. The simpler the execution of the program, the easier it is to grasp for the student. It may be obvious that the 
Sequential Execution is the most simple form of execution there is, but if the software includes boolean types, it is not always possible to deduce 
what is the next bit of code which will run. Therefore to make the program simple to understand and read, sequential execution would work best, with a 
bare minimum of boolean types, which incidentally is the hardest type to understand.

\subsubsection{Level of Abstraction}

The lower the level of abstraction the more does the programmer need to know about the computer which runs the software. Therefore, for teaching 
purposes a higher level of abstraction is considered easier for students to learn than a language with a low level of abstraction.\todo{return later}